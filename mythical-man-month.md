#### Joys of the Craft
* The sheer joy of making things.
* The pleasure of making things that are useful to other people.
* Watching complex objects of moving parts work together in subtle cycles.
* The joy of always learnings which springs from the non-repeating nature of the task.
* The delight of working in such a tractable medium. Creating by exertion of imagination. Few media of creation lend themselves to flexibility and so readily capable of realizing conceptual structures.

> Programming then is fun because it gratifies creative longings built deep within us and delights sensibilities we have in common with all men.

#### Woes of the Craft
* Adjusting to the requirement of perfection is the most difficult part of learning to program.
* Dependence upon others is another woe, much of the code is maldesigned, poorly implemented and incompletely delivered. Much of the time is spent fixing things that in an ideal world would be readily available.
* With any creative activity come dary hours of tedious, painstaking labor and programming is no exception.
* Testing drags on and on, the last difficult bugs taking more time to find than the first.
* The product upon which one a labored so long appears to be obsolete upon completion.

> Implementation of real products demands phasing and quantizing. The obsolescence of an implementation must be measured against other existing implementations, not against unrealized concepts. The challenge and the mission is to find real solutions to real problems on actual schedules with available resources.

#### Optimism

More software projects have gone awry for lack of calendar time than anything else. This is because our techniques for estimating are poor developed. We confuse effort with progress. The schedule progress is poorly managed and the natural response to schedule slippage is adding more man power, which is like dousing fire with more gasoline.

> The first false assumption that underlies scheduling of systems programming is that all will go well, i.e. that each task will take only as long as it ought to take. 

The programmer builds stuff from thoughts. Because the medium is tractable, we expect few diffiulties and hence our optimism. For each task there is a probability that it will go well. A large programming effort consists of many small tasks chained together. The probability that each will go well becomes vanishingly small. 

> Cost is measured in Man and Months, while progress is not. It would imply man and months are interchangable which is dangerous and a deceptive myth

Testing is usally the most mis-scheduled part of programming, because of optimism we expect the number of errors to be smaller than it turns out to be. Author's rule of thumb scheduling. 
* 1/3 planning
* 1/6 coding
* 1/4 component testing
* 1/4 system test



